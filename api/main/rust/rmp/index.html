<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The Rust MessagePack Library"><title>rmp - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-63a85fc7cf22dee2.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="rmp" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0-nightly (696aaad58 2023-04-09)" data-search-js="search-bc5a112813b5d712.js" data-settings-js="settings-298e1ea74db45b39.js" data-settings-css="settings-0bcba95ff279c1db.css" data-theme-light-css="light-db279b6232be9c13.css" data-theme-dark-css="dark-cf923f49f397b216.css" data-theme-ayu-css="ayu-be46fdc453a55015.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-1159a395118aa44e.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-db279b6232be9c13.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-cf923f49f397b216.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../rmp/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../rmp/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate rmp</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.8.11</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">rmp</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/rmp/lib.rs.html#1-162">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="the-rust-messagepack-library"><a href="#the-rust-messagepack-library">The Rust MessagePack Library</a></h2>
<p>RMP is a pure Rust <a href="http://msgpack.org">MessagePack</a> implementation of an efficient binary
serialization format. This crate provides low-level core functionality, writers and readers for
primitive values with direct mapping between binary MessagePack format.</p>
<p><strong>Warning</strong> this library is still in rapid development and everything may change until 1.0
comes.</p>
<h3 id="usage"><a href="#usage">Usage</a></h3>
<p>To use <code>rmp</code>, first add this to your <code>Cargo.toml</code>:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies.rmp]
rmp = &quot;^0.8&quot;
</code></pre></div>
<p>Then, add this line to your crate root:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>rmp;</code></pre></div>
<h3 id="features"><a href="#features">Features</a></h3>
<ul>
<li>
<p><strong>Convenient API</strong></p>
<p>RMP is designed to be lightweight and straightforward. There are low-level API, which gives you
full control on data encoding/decoding process and makes no heap allocations. On the other hand
there are high-level API, which provides you convenient interface using Rust standard library and
compiler reflection, allowing to encode/decode structures using <code>derive</code> attribute.</p>
</li>
<li>
<p><strong>Zero-copy value decoding</strong></p>
<p>RMP allows to decode bytes from a buffer in a zero-copy manner easily and blazingly fast, while Rust
static checks guarantees that the data will be valid until buffer lives.</p>
</li>
<li>
<p><strong>Clear error handling</strong></p>
<p>RMP’s error system guarantees that you never receive an error enum with unreachable variant.</p>
</li>
<li>
<p><strong>Robust and tested</strong></p>
<p>This project is developed using TDD and CI, so any found bugs will be fixed without breaking
existing functionality.</p>
</li>
</ul>
<h3 id="detailed"><a href="#detailed">Detailed</a></h3>
<p>This crate represents the very basic functionality needed to work with MessagePack format.
Ideologically it is developed as a basis for building high-level abstractions.</p>
<p>Currently there are two large modules: encode and decode. More detail you can find in the
corresponding sections.</p>
<p>Formally every MessagePack message consists of some marker encapsulating a data type and the
data itself. Sometimes there are no separate data chunk, for example for booleans. In these
cases a marker contains the value. For example, the <code>true</code> value is encoded as <code>0xc3</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>buf = Vec::new();
rmp::encode::write_bool(<span class="kw-2">&amp;mut </span>buf, <span class="bool-val">true</span>).unwrap();

<span class="macro">assert_eq!</span>([<span class="number">0xc3</span>], buf[..]);</code></pre></div>
<p>Sometimes a single value can be encoded in multiple ways. For example a value of <code>42</code> can be
represented as: <code>[0x2a], [0xcc, 0x2a], [0xcd, 0x00, 0x2a]</code> and so on, and all of them are
considered as valid representations. To allow fine-grained control over encoding such values
the library provides direct mapping functions.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>bufs = <span class="macro">vec!</span>[<span class="macro">vec!</span>[]; <span class="number">5</span>];

rmp::encode::write_pfix(<span class="kw-2">&amp;mut </span>bufs[<span class="number">0</span>], <span class="number">42</span>).unwrap();
rmp::encode::write_u8(<span class="kw-2">&amp;mut </span>bufs[<span class="number">1</span>], <span class="number">42</span>).unwrap();
rmp::encode::write_u16(<span class="kw-2">&amp;mut </span>bufs[<span class="number">2</span>], <span class="number">42</span>).unwrap();
rmp::encode::write_u32(<span class="kw-2">&amp;mut </span>bufs[<span class="number">3</span>], <span class="number">42</span>).unwrap();
rmp::encode::write_u64(<span class="kw-2">&amp;mut </span>bufs[<span class="number">4</span>], <span class="number">42</span>).unwrap();

<span class="macro">assert_eq!</span>([<span class="number">0x2a</span>], bufs[<span class="number">0</span>][..]);
<span class="macro">assert_eq!</span>([<span class="number">0xcc</span>, <span class="number">0x2a</span>], bufs[<span class="number">1</span>][..]);
<span class="macro">assert_eq!</span>([<span class="number">0xcd</span>, <span class="number">0x00</span>, <span class="number">0x2a</span>], bufs[<span class="number">2</span>][..]);
<span class="macro">assert_eq!</span>([<span class="number">0xce</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x2a</span>], bufs[<span class="number">3</span>][..]);
<span class="macro">assert_eq!</span>([<span class="number">0xcf</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x2a</span>], bufs[<span class="number">4</span>][..]);</code></pre></div>
<p>But they aren’t planned to be widely used. Instead we often need to encode bytes compactly to
save space. In these cases RMP provides functions that guarantee that for encoding the most
compact representation will be chosen.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>buf = Vec::new();

rmp::encode::write_sint(<span class="kw-2">&amp;mut </span>buf, <span class="number">300</span>).unwrap();

<span class="macro">assert_eq!</span>([<span class="number">0xcd</span>, <span class="number">0x1</span>, <span class="number">0x2c</span>], buf[..]);</code></pre></div>
<p>On the other hand for deserialization it is not matter in which representation the value is
encoded - RMP deals with all of them.</p>
<p>Sometimes you know the exact type representation and want to enforce the deserialization process
to make it strongly type safe.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>buf = [<span class="number">0xcd</span>, <span class="number">0x1</span>, <span class="number">0x2c</span>];

<span class="macro">assert_eq!</span>(<span class="number">300</span>, rmp::decode::read_u16(<span class="kw-2">&amp;mut &amp;</span>buf[..]).unwrap());</code></pre></div>
<p>However if you try to decode such bytearray as other integer type, for example <code>u32</code>, there will
be type mismatch error.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>buf = [<span class="number">0xcd</span>, <span class="number">0x1</span>, <span class="number">0x2c</span>];
rmp::decode::read_u32(<span class="kw-2">&amp;mut &amp;</span>buf[..]).err().unwrap();</code></pre></div>
<p>But sometimes all you want is just to encode an integer that <em>must</em> fit in the specified type
no matter how it was encoded. RMP provides <a href="decode/fn.read_int.html"><code>such</code></a> function to ease integration with
other MessagePack libraries.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>buf = [<span class="number">0xcd</span>, <span class="number">0x1</span>, <span class="number">0x2c</span>];

<span class="macro">assert_eq!</span>(<span class="number">300i16</span>, rmp::decode::read_int(<span class="kw-2">&amp;mut &amp;</span>buf[..]).unwrap());
<span class="macro">assert_eq!</span>(<span class="number">300i32</span>, rmp::decode::read_int(<span class="kw-2">&amp;mut &amp;</span>buf[..]).unwrap());
<span class="macro">assert_eq!</span>(<span class="number">300i64</span>, rmp::decode::read_int(<span class="kw-2">&amp;mut &amp;</span>buf[..]).unwrap());
<span class="macro">assert_eq!</span>(<span class="number">300u16</span>, rmp::decode::read_int(<span class="kw-2">&amp;mut &amp;</span>buf[..]).unwrap());
<span class="macro">assert_eq!</span>(<span class="number">300u32</span>, rmp::decode::read_int(<span class="kw-2">&amp;mut &amp;</span>buf[..]).unwrap());
<span class="macro">assert_eq!</span>(<span class="number">300u64</span>, rmp::decode::read_int(<span class="kw-2">&amp;mut &amp;</span>buf[..]).unwrap());</code></pre></div>
<h3 id="api"><a href="#api">API</a></h3>
<p>Almost all API are represented as pure functions, which accepts a generic <code>Write</code> or <code>Read</code> and
the value to be encoded/decoded. For example let’s do a round trip for π number.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>pi = std::f64::consts::PI;
<span class="kw">let </span><span class="kw-2">mut </span>buf = Vec::new();
rmp::encode::write_f64(<span class="kw-2">&amp;mut </span>buf, pi).unwrap();

<span class="macro">assert_eq!</span>([<span class="number">0xcb</span>, <span class="number">0x40</span>, <span class="number">0x9</span>, <span class="number">0x21</span>, <span class="number">0xfb</span>, <span class="number">0x54</span>, <span class="number">0x44</span>, <span class="number">0x2d</span>, <span class="number">0x18</span>], buf[..]);
<span class="macro">assert_eq!</span>(pi, rmp::decode::read_f64(<span class="kw-2">&amp;mut &amp;</span>buf[..]).unwrap());</code></pre></div>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="decode/index.html" title="mod rmp::decode">decode</a></div><div class="desc docblock-short">Provides various functions and structs for MessagePack decoding.</div></li><li><div class="item-name"><a class="mod" href="encode/index.html" title="mod rmp::encode">encode</a></div><div class="desc docblock-short">Provides various functions and structs for MessagePack encoding.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Marker.html" title="enum rmp::Marker">Marker</a></div><div class="desc docblock-short">Format markers.</div></li></ul><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.MSGPACK_VERSION.html" title="constant rmp::MSGPACK_VERSION">MSGPACK_VERSION</a></div><div class="desc docblock-short">Version of the MessagePack <a href="http://github.com/msgpack/msgpack/blob/master/spec.md">spec</a>.</div></li></ul></section></div></main></body></html>